<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="UTF-8"/><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><link rel="apple-touch-icon" sizes="180x180" href="../ydoc/images/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="../ydoc/images/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="../ydoc/images/favicon-16x16.png"/><link rel="manifest" href="../ydoc/images/manifest.json"/><link rel="mask-icon" href="../ydoc/images/safari-pinned-tab.svg" color="#5bbad5"/><meta name="theme-color" content="#ffffff"/><meta http-equiv="Cache-Control" content="no-transform"/><meta http-equiv="Cache-Control" content="no-siteapp"/><title>documents</title><link rel="stylesheet" href="../ydoc/styles/style.css"/><meta name="author" content="ymfe"/><meta name="keywords"/><meta name="description" content="website description"/><meta id="releativePath" content=".."/><link rel="stylesheet" href="../ydoc/ydoc-plugin-search/search.css"/></head><body><div class="g-doc"><div class="m-aside"><div class="m-summary" id="js-menu"><div class="m-summary-content" id="js-menu-content"><div class="m-summary-block"><ul class="m-summary-list"><li class="item"><a href="" class="href">A</a></li></ul></div><div class="m-summary-block"><div class="m-summary-title">Getting Started</div><ul class="m-summary-list indent"><li class="item"><div class="m-summary-block"><a href="intro.html#" class="href">Introduction</a><ul class="m-summary-list indent"><li class="item"><a href="env.html" class="href">env</a></li></ul></div></li></ul></div></div></div><div class="m-summary-switch" id="js-summary-switch"><svg viewBox="0 0 926.23699 573.74994" version="1.1" x="0px" y="0px" width="15" height="15" class="bottom"><g transform="translate(904.92214,-879.1482)"><path d="m -673.67664,1221.6502 -231.2455,-231.24803 55.6165,-55.627 c 30.5891,-30.59485 56.1806,-55.627 56.8701,-55.627 0.6894,0 79.8637,78.60862 175.9427,174.68583 l 174.6892,174.6858 174.6892,-174.6858 c 96.079,-96.07721 175.253196,-174.68583 175.942696,-174.68583 0.6895,0 26.281,25.03215 56.8701,55.627 l 55.6165,55.627 -231.245496,231.24803 c -127.185,127.1864-231.5279,231.248 -231.873,231.248 -0.3451,0 -104.688,-104.0616 -231.873,-231.248 z" fill="#fff"></path></g></svg><svg viewBox="0 0 926.23699 573.74994" version="1.1" x="0px" y="0px" width="15" height="15" class="top"><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="aaa" fill="#fff" fill-rule="nonzero"><path d="M231.2455,342.502 L0,111.25397 L55.6165,55.62697 C86.2056,25.03212 111.7971,-2.99999998e-05 112.4866,-2.99999998e-05 C113.176,-2.99999998e-05 192.3503,78.60859 288.4293,174.6858 L463.1185,349.3716 L637.8077,174.6858 C733.8867,78.60859 813.060896,-2.99999997e-05 813.750396,-2.99999997e-05 C814.439896,-2.99999997e-05 840.031396,25.03212 870.620496,55.62697 L926.236996,111.25397 L694.9915,342.502 C567.8065,469.6884 463.4636,573.75 463.1185,573.75 C462.7734,573.75 358.4305,469.6884 231.2455,342.502 Z" id="Shape" transform="translate(463.118498, 286.874985) scale(1, -1) translate(-463.118498, -286.874985) "></path></g></g></svg></div></div><div class="m-main" id="js-panel"><header class="m-header" id="js-header"><div class="m-header-title js-logo"><a href="../index.html" target="_self"><img class="logo" width="36" src="../ydoc/images/dog@1x.png"/><h6 class="name">YDoc</h6></a></div><div><div class="m-search">
      <div class="icon">&#xf0fd;</div>
      <input type="text" class="input js-input" placeholder="搜索" />
      <div class="m-search-result js-search-result"></div>
    </div></div><nav class="m-header-nav js-nav"><ul class="m-header-items"><li class="item active"><a class="href" href="index.html">documents</a></li><li class="item "><a class="href" href="../about/index.html">about</a></li></ul></nav><div id="js-nav-btn" class="m-header-btn ui-font-ydoc"></div></header><div class="m-content" id="js-content"><div id="markdown-body" class="m-content-container markdown-body"><h2 id="一面">一面</h2>
<ol>
<li>简单介绍下自己</li>
<li>说说做的最好的项目</li>
<li>项目里有哪些难题，怎么解决</li>
</ol>
<hr>
<ol start="4">
<li>python：浅拷贝和深拷贝的区别，怎么读取大文件<br>
赋值:用一个变量给另一个变量赋值，给内存对象加标签<br>
浅拷贝:创建一个新的组合对象，这个新对象与原对象共享内存中的子对象。<br>
深拷贝：创建一个新的组合对象，同时递归地拷贝所有子对象，新的组合对象与原对象没有任何关联。虽然实际上会共享不可变的子对象，但不影响它们的相互独立性。<br>
大文件：交给解释器，用with语句打开和关闭文件，包括抛出一个内部块异常。for line in f文件对象f视为一个迭代器，会自动的采用缓冲IO和内存管理，所以你不必担心大文件。</li>
</ol>
<pre><code>with open(...) as f:  
&#x3000;&#x3000;for line in f:  
&#x3000;&#x3000;&#x3000;&#x3000;process(line) 
</code></pre>
<hr>
<ol start="5">
<li>数据库：图书馆数据库有两张表，图书信息Info和借还记录Record</li>
<li>求id在25000到50000之间的书的信息</li>
<li>表的数据量太大，做这个查询有什么隐患</li>
<li>索引怎么建立？
<ol>
<li>主键索引</li>
<li>惟一值索引</li>
<li>普通索引<br>
create unique index isbn on book(isbn(5))</li>
</ol>
</li>
</ol>
<hr>
<ol start="11">
<li>数据库引擎有什么了解<br>
MyIASM引擎是为了查和增加，效率高。所有功能都围绕这这个。<br>
Innodb引擎功能更强（事务等）效率低一些。<br>
https://blog.csdn.net/sjyttkl/article/details/76176836<br>
MyISAM：MyISAM是MySQL的ISAM扩展格式和缺省的数据库引擎。除了提供ISAM里所没有的索引和字段管理的大量功能，MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMCHK工具和用来恢复浪费空间的 MyISAMPACK工具。MYISAM强调了快速读取操作，这可能就是为什么MySQL受到了WEB开发如此青睐的主要原因：在WEB开发中你所进行的大量数据操作都是读取操作。所以，大多数虚拟主机提供商和INTERNET平台提供商只允许使用MYISAM格式。MyISAM格式的一个重要缺陷就是不能在表损坏后恢复数据。<br>
InnoDB：InnoDB数据库引擎都是造就MySQL灵活性的技术的直接产品，这项技术就是MYSQL+API。在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MyISAM数据库引擎不支持事务处理（transaction process）也不支持外来键。尽管要比ISAM和 MyISAM引擎慢很多，但是InnoDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。如前所述，如果你的设计需要这些特性中的一者 或者两者，那你就要被迫使用后两个引擎中的一个了。<br>
MyISAM与InnoDB的区别<br>
　　InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。<br>
一般来说，MyISAM适合：
<ol>
<li>做很多count 的计算；</li>
<li>插入不频繁，查询非常频繁；</li>
<li>没有事务。<br>
InnoDB适合：</li>
<li>可靠性要求比较高，或者要求事务；</li>
<li>表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定数据引擎的创建</li>
</ol>
</li>
</ol>
<hr>
<ol start="12">
<li>数据量特别大的背景下，怎么去优化这个查询，解决安全隐患和提升速度），有哪些方案？（答的索引）</li>
</ol>
<ul>
<li>查询速度慢的原因:
<ol>
<li>没有索引或者没有用到索引（这是查询慢最常见的问题，是程序设计的缺陷）</li>
<li>I/O 吞吐量小，形成了瓶颈效应。</li>
<li>没有创建计算列导致查询不优化。</li>
<li>内存不足</li>
<li>网络速度慢</li>
<li>查询出的数据量过大（可采用多次查询，其他的方法降低数据量）</li>
<li>锁或者死锁（这是查询慢最常见的问题，是程序设计的缺陷）</li>
<li>sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。</li>
<li>返回了不必要的行和列</li>
<li>查询语句不好，没有优化</li>
</ol>
</li>
<li>优化查询:
<ol>
<li>给字段选取合适的数据类型，如CHAR和VARCHAR</li>
<li>BLOB和TEXT做删除或更新时会留下大空洞，要定期使用OPTMIZE TABLE来碎片整理，建议单独拿出来存储，或者根据MD5值建立索引来查找。</li>
<li>使用NOT NULL，把数据列定义为非空，简化查询</li>
<li>使用缓存查询，数据表更新后缓存查询变成无效，防止服务产生过期结果。</li>
</ol>
</li>
<li>安全性:
<ol>
<li>防止sql注入,对特殊字符进行转译与过滤,使用sql语句绑定变量</li>
<li>最小用户权限设置,最好不要使用root用户连接数据库</li>
<li>当sql运行出错的时候,不要将错误信息全部显示给用户</li>
</ol>
</li>
</ul>
<ol start="13">
<li>表里面有大量重复数据（id相同），有什么办法去做优化？<br>
MySQL有一个独有的 alter ignore add unique index的语法。<br>
<code>ALTER [ONLINE | OFFLINE] [IGNORE] TABLE tbl_name</code><br>
行为类似于insert ignore，即遇到冲突的unique数据则直接抛弃而不报错。对于加唯一索引的情况来说就是建一张空表，然后加上唯一索引，将老数据用insert ignore语法插入到新表中，遇到冲突则抛弃数据。alter ignore的语法不支持innodb，所以需要把table的引擎改为MyISAM;<br>
解决方案</li>
</ol>
<pre><code>ALTER TABLE tableA ENGINE MyISAM;   /*&#x6CE8;&#x610F;&#xFF1A;&#x4FEE;&#x6539;&#x8868;&#x7ED3;&#x6784;&#x4E3A;MyISAM */  
ALTER IGNORE TABLE tableA ADD UNIQUE INDEX idx_col1_u (col1); /*&#x6DFB;&#x52A0;&#x552F;&#x4E00;&#x7D22;&#x5F15;&#xFF0C;&#x6D88;&#x91CD;*/  
ALTER TABLE table ENGINE InnoDB;    /*&#x53EF;&#x9009;&#xFF0C;&#x4FEE;&#x6539;&#x8868;&#x7ED3;&#x6784;&#x4E3A;InnoDB */
</code></pre>
<hr>
<ol start="14">
<li>进程和线程有什么不一样。<br>
进程线程的区别：<br>
地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。<br>
资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。<br>
一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。<br>
进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。</li>
</ol>
<hr>
<ol start="16">
<li>如果B和D去竞争同一个资源，应该加什么锁？进程锁还是线程锁还是数据库锁？为什么？
<ol>
<li>新建线程之后,开启start的那一瞬间:线程对象会进入可调度线程池中</li>
<li>start开始之后,线程会在就绪和运行两个状态中来回切换(CPU调用哪个线程, 哪个线程就是运行状态,可调度线程池中的其他线程则为就绪状态)</li>
<li>start之后如果调用了sleep或同步锁等方法造成线程阻塞的时候,该线程会被移出可调度线程池,阻塞结束后线程会重新进入可调度线程池</li>
<li>线程结束,或异常退出时候这条线程进入死亡状态,线程死亡后不可以再次接受start消息,也就是说线程不能再重新开启<br>
一块资源可能会被多个线程共享,当多个线程访问同一块资源的时候,会发生数据错乱或数据安全的问题。</li>
</ol>
</li>
</ol>
<ul>
<li>隐患的解决办法:加互斥锁
<ol>
<li>第一个线程调用资源的时候先去看一下资源有没有被锁</li>
<li>如果没有就去调用资源并对资源加锁,调用结束之后再解锁</li>
<li>第二条线程调用资源的时候也先去看一下资源有没有被锁,如果发现有锁,就进入阻塞状态,</li>
<li>直到资源解锁之后自己在调用,而第二条线程调用的时候继续给资源加锁,并在调用完成后解锁</li>
</ol>
</li>
</ul>
<p>关于进程和线程:<br>
1.进程与线程<br>
进程：具有独立功能的程序关于某个数据集合上的一次运行活动。
线程：进程的一个实体。
比喻：一列火车是一个进程，火车的每一节车厢是线程。</p>
<p>2.进程与线程的联系<br>
①一个线程只能属于一个进程，一个进程可以有多个线程；
②系统资源分配给进程，同一进程的所有线程共享该进程的所有资源；
③真正在处理机上运行的是线程；
④不同进程的线程间利用消息通信的方式实现同步。</p>
<p>3.进程与线程的区别<br>
①调度：线程是系统调度和分配的基本单位，进程是作为拥有系统资源的基本单位；
②并发性：进程之间可以并发执行，同一进程的多个线程时间亦可以并发执行；
③拥有资源：进程是拥有资源的独立单位，线程不拥有资源，但可以访问隶属于进程的资源；
④系统开销：创建和撤销进程的开销更大；进程拥有独立的地址空间，一个进程的崩溃不会影响其他进程；线程拥有自己的堆栈和局部变量，没有独立的地址空间，因此进程里的一个线程崩溃会导致其他线程均崩溃。</p>
<p>4.进程间通信方式<br>
进程间通信方式有很多，网上一说有十几种。面试的时候说上以下几种差不多：
①管道：半双工的通信方式，数据只能单向流动，且只能在有亲缘关系（父子进程或兄弟进程）的进程间使用；
②命名管道：FIFO，半双工的通信方式，但允许在无亲缘关系的进程间通信；
③消息队列：消息的链表，存放在内核中，并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点；
④信号量：是一个计数器，用于控制多个进程间对共享资源的访问；
⑤共享内存：映射一段能被其他进程访问的内存，这段内存由一个进程创建，但多个进程都可以访问；
⑥套接字</p>
<p>5.线程间通信方式<br>
多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。<br>
①锁机制：包括互斥锁、条件变量、读写锁<br>
互斥锁提供了以排他方式防止数据结构被并发修改的方法。
读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。<br>
②信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量<br>
③信号机制(Signal)：类似进程间的信号处理<br>
线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<h2 id="二面">二面</h2>
<p>Linux：</p>
<ol>
<li>linux下怎么关闭一个进程
ps查找PID号，然后kill PID</li>
<li>要删除/tmp下大于1GB的文件</li>
</ol>
<pre><code>find /tmp -type f -size +1048576k -exec rm -f {} \;
</code></pre>
<ol start="3">
<li>现在有很多跟MySQL相关的进程，进程名都是MySQL开头的，怎么把这些进程找出来并且关掉<br>
<code># ps -ef | grep xxx + kill -9 PID</code><br>
数据库：</li>
<li>left outer join跟join有什么区别<br>
没区别</li>
<li>left join的同时想要加过滤条件，加在on子句还是where子句<br>
跟在ON 后面的条件是对参与左联接的数据进行筛选，即在左联接之前起作用。<br>
跟在WHERE后的条件是对左联接得到的结果集进行筛选，即在左联接之后起作用。
针对单表字段构成的筛选条件这种情况，最好的做法是直接将条件放到WHERE子句中。</li>
<li>python有哪些数据类型<br>
数字：int类，<br>
布尔值：bool类<br>
字符串：str类<br>
列表：list类<br>
元组：tuple类<br>
字典：dict类<br>
集合：set类</li>
<li>python中int类型的数占几个字节<br>
sys.getsizeof(0) 数组元素为0。此时占用24字节（PyObject_VAR_HEAD 的大小）。 sys.getsizeof(456) 需使用一个元素，因此多了4个字节（28）。<br>
数据库：<br>
现在有个200TB的数据，要求响应时间在200ms以内，怎么去做查询（答的索引）</li>
<li>现在有200GB的txt数据，内存64GB的服务器，要有一个API去做数据的查询，要求响应时间在200ms以内，怎么考虑？</li>
<li>说说web服务器怎么处理千万级并发的访问（比如同时加载QQ头像），从接入层到逻辑层来讲讲<br>
思路：
<ol>
<li>HTML静态化</li>
<li>图片服务器分离</li>
<li>数据库集群、库表散列<br>
我们在应用程序中安装业务和应用或者功能模块将数据库进行分离，不同的模块对应不同的数据库或者表，再按照一定的策略对某个页面或者功能进行更小的数据库散列，比如用户表，按照用户ID进行表散列，这样就能够低成本的提升系统的性能并且有很好的扩展性。</li>
<li>缓存</li>
<li>镜像</li>
<li>负载均衡 硬件四层交换 软件四层交换</li>
<li>CDN加速技术
CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。<br>
计网：</li>
</ol>
</li>
<li>讲讲UDP的包最多可以发多少数据<br>
UDP 包的大小就应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)<br>
TCP 包的大小就应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)</li>
</ol>
<hr>
<ol start="12">
<li>TCP跟UDP相比，为什么更可靠<br>
TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</li>
</ol>
<hr>
<ol start="13">
<li>讲讲XSS攻击的定义，以及怎么去防御<br>
CSS(Cross-Site Scripting)，跨站脚本攻击。XSS攻击就是攻击者通过各种办法，在用户访问的网页中插入自己的脚本，让其在用户访问网页时在其浏览器中进行执行。攻击者通过插入的脚本的执行，来获得用户的信息，比如cookie，发送到攻击者自己的网站(跨站了)。XSS可以分为反射型XSS和持久性XSS，还有DOM Based XSS。(一句话，XSS就是在用户的浏览器中执行攻击者自己定制的脚本。)
XSS防御的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。
<ol>
<li>对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行html编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的XSS攻击。</li>
<li>对于输入，处理使用XSS filter之外，对于每一个输入，在客户端和服务器端还要进行各种验证，验证是否合法字符，长度是否合法，格式是否正确。在客户端和服务端都要进行验证，因为客户端的验证很容易被绕过。其实这种验证也分为了黑名单和白名单。黑名单的验证就是不能出现某些字符，白名单的验证就是只能出现某些字符。尽量使用白名单。</li>
<li>对输出进行编码。在输出数据之前对潜在的威胁的字符进行编码、转义是防御XSS攻击十分有效的措施。如果使用好的话，理论上是可以防御住所有的XSS攻击的。</li>
</ol>
</li>
<li>讲讲DDOS攻击，以及怎么防御<br>
DDOS：分布式拒绝服务，在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。<br>
常见攻击：利用不断对网站发送连接请求致使形成拒绝服务的目的。业界赋予这种攻击名称为CC（Challenge Collapsar，挑战黑洞）
防御方法：
<ol>
<li>备份网站，静态浏览，显示公告</li>
<li>HTTP请求的拦截，架设防火墙，封IP段， User Agent字段有特征就针对拦截</li>
<li>带宽扩容，有大量冗余带宽，短时间内急剧扩容，消化DDOS</li>
<li>CDN。网站域名指向高防IP，它提供一个缓冲层，清洗流量，并对源服务器的内容进行缓存。上了CDN，千万不要泄露源服务器的IP地址。</li>
</ol>
</li>
</ol>
<p>问了jvm内存回收是怎么回事</p>
<ol>
<li>数据结构线性表和链表区别，堆和栈区别，hash是什么，怎么解决冲突。<br>
线性表:用一段连续的存储单元依次存储线性表的数据元素<br>
链表:采用链式存储结构，用一组任意的存储单元存放线性表的元素<br>
1）当线性表需要频繁查找，较少插入和删除时，宜采用顺序存储结构。若需要频繁插入和删除，宜采用单链表。<br>
2）当线性表的元素个数变化较大或不确定时，最好用单链表，这样不需要考虑存储空间大小问题。当事先知道线性表的大小长度，用顺序存储结构效率会高一些。<br>
堆: 可以理解为二叉树的一种，是节点间有序关系的完全二叉树，所以可以用数组来表示。<br>
栈:具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。<br>
hash:散列，在加密方面，Hash哈希是把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做HASH值<br>
开放散列（open hashing）/ 拉链法（针对桶链结构）<br>
1）优点： ①对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销） ②由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了 ③删除记录时，比较方便，直接通过指针操作即可<br>
2）缺点： ①存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 ②如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列 ③由于使用指针，记录不容易进行序列化（serialize）操作<br>
封闭散列（closed hashing）/ 开放定址法<br>
1）优点： ①记录更容易进行序列化（serialize）操作 ②如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的<br>
2）缺点： ①存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷 ②使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低 ③由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费 ④删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。</li>
<li>操作系统进程是什么，线程是什么，区别，虚拟内存是什么，物理内存是什么，区别，还问了一个什么问题我一直没听清，估计他也听恼火的就过了。。。</li>
</ol>
<p>计算机网络tcp和udp区别，tcp怎么连接，怎么释放连接，为什么要四次挥手</p>
<p>mysql用过吗？用的什么引擎，innodb有什么特点</p>
<p>给我讲讲排序算法有哪些<br>
比较排序：</p>
<p>涉及知识：</p>
<p>分治法：将一个问题分解成规模更小、结构相似的子问题，解决问题A，变成了解决问题A1和A2，解决问题A1变成了解决问题A11和A12。。。，一直到最小单元，当最小单元问题解决后，依次向上返回，问题A得以解决。因为问题和子问题之间解决思路是相似的，所以解决时会调用相同的程序体，表现为问题调用自己解决子问题，而结果则是从最小单元依次向上返回，称之为递归。在递归过程中，子问题的规模不断在缩小。</p>
<ol>
<li>
<p>插入排序：在已排序好的序列中，给要插入元素找到并空出应在位置，并插入该元素。</p>
</li>
<li>
<p>合并排序：将排序分解为合并两个内部已排好序的子序列的问题，表现为先排序分拆的子序列再递归合并。</p>
</li>
<li>
<p>冒泡排序：每次必将一个最大或最小元素像水中气泡一样，升到最高水面（放在序列最前面），关键：在冒泡的过程中，顺便会交换排序不对的两个相邻元素，这点与选择排序不同。例：3，2，6，5，4，在4冒泡时，会将4放置到6的前面，然后再让2冒泡；而选择排序只会对比得出4大于2，让2放到最前，4的位置不变化。</p>
</li>
<li>
<p>堆排序：利用最大/小堆的所有子树根节点的值都是最值的特点，建立堆，取根节点，对剩余元素继续建立堆，通过此过程实现排序。</p>
</li>
<li>
<p>快速排序：使用一个分界点，将一个序列分成小于和大于分界点的两个子序列（子序列内部并未排序），表现为先设置分界点划分两个序列，再递归排序每个子序列。</p>
</li>
</ol>
<p>非比较排序：</p>
<p>涉及知识：</p>
<p>稳定排序：进行排序的相等元素，在输入和输出时的相对位置保持不变。</p>
<ol>
<li>
<p>计数排序：记录每个元素出现的次数，计算得出每个元素应该在的位置。该排序方法要求知道排序元素是那些，才可实现对这些元素进行计数。该排序可以是稳定排序。</p>
</li>
<li>
<p>基数排序：从低位向高位逐列排序。低位排出一个顺序，如果高位不能改（相等），那么保持顺序不变（所以高位排序要求是稳定排序），如果高位能改，那么按照高位改变排序。由低向高排序的原因，由高向低排序时，低位无权修改高位的排序，因为需要数据按照高位的值分成不同部分（1的在一起，2的在一起。。。，避免低位修改了高位排序），再在每个部分内部进行低位排序。</p>
</li>
<li>
<p>桶排序：通过对比元素和桶基数，将元素散布到多个桶中，（也是一种hash算法），再将桶内元素排序，即可实现排序。
解释一下快速排序:<br>
通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
</li>
</ol>
<p>运营开发是大概做什么的了。做的是大数据方面的应用，数据采集，数据处理，数据存储，数据分析，数据结果平台展现。</p>
<p>linux查看内存，cpu占用命令？<br>
top<br>
端口占用命令？<br>
lsof -i:端口号</p>
<ol start="3">
<li>
<p>会mysql吗？说一下他的引擎</p>
</li>
<li>
<p>会进程和线程吗？说说他们的区别</p>
</li>
<li>
<p>线程占用资源吗？</p>
</li>
<li>
<p>写一个线程池</p>
</li>
</ol>
<pre><code>import queue
import threading
import time

class ThreadPool(object):  #&#x521B;&#x5EFA;&#x7EBF;&#x7A0B;&#x6C60;&#x7C7B;

    def __init__(self, max_num=20):  #&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x6700;&#x5927;&#x957F;&#x5EA6;&#x4E3A;20&#x7684;&#x961F;&#x5217;
        self.queue = queue.Queue(max_num)  #&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x961F;&#x5217;
        for i in range(max_num):  #&#x5FAA;&#x73AF;&#x628A;&#x7EBF;&#x7A0B;&#x5BF9;&#x8C61;&#x52A0;&#x5165;&#x5230;&#x961F;&#x5217;&#x4E2D;
            self.queue.put(threading.Thread)  #&#x628A;&#x7EBF;&#x7A0B;&#x7684;&#x7C7B;&#x540D;&#x653E;&#x8FDB;&#x53BB;&#xFF0C;&#x6267;&#x884C;&#x5B8C;&#x8FD9;&#x4E2A;Queue

    def get_thread(self):  #&#x5B9A;&#x4E49;&#x65B9;&#x6CD5;&#x4ECE;&#x961F;&#x5217;&#x91CC;&#x83B7;&#x53D6;&#x7EBF;&#x7A0B;
        return self.queue.get()  #&#x5728;&#x961F;&#x5217;&#x4E2D;&#x83B7;&#x53D6;&#x503C;

    def add_thread(self):  #&#x7EBF;&#x7A0B;&#x6267;&#x884C;&#x5B8C;&#x4EFB;&#x52A1;&#x540E;&#xFF0C;&#x5728;&#x961F;&#x5217;&#x91CC;&#x6DFB;&#x52A0;&#x7EBF;&#x7A0B;
        self.queue.put(threading.Thread)

def func(pool,a1):
    time.sleep(1)
    print(a1)
    pool.add_thread()  #&#x7EBF;&#x7A0B;&#x6267;&#x884C;&#x5B8C;&#x4EFB;&#x52A1;&#x540E;&#xFF0C;&#x961F;&#x5217;&#x91CC;&#x518D;&#x52A0;&#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;

p = ThreadPool(10)  #&#x6267;&#x884C;init&#x65B9;&#x6CD5;&#xFF1B;  &#x4E00;&#x6B21;&#x6700;&#x591A;&#x6267;&#x884C;10&#x4E2A;&#x7EBF;&#x7A0B;

for i in range(100):
    thread = p.get_thread()  #&#x7EBF;&#x7A0B;&#x6C60;10&#x4E2A;&#x7EBF;&#x7A0B;&#xFF0C;&#x6BCF;&#x4E00;&#x6B21;&#x5FAA;&#x73AF;&#x62FF;&#x8D70;&#x4E00;&#x4E2A;&#x62FF;&#x5230;&#x7C7B;&#x540D;&#xFF0C;&#x6CA1;&#x6709;&#x5C31;&#x7B49;&#x5F85;
    t = thread(target=func, args=(p, i,))  #&#x521B;&#x5EFA;&#x7EBF;&#x7A0B;&#xFF1B;  &#x7EBF;&#x7A0B;&#x6267;&#x884C;func&#x51FD;&#x6570;&#x7684;&#x8FD9;&#x4E2A;&#x4EFB;&#x52A1;&#xFF1B;args&#x662F;&#x7ED9;&#x51FD;&#x6570;&#x4F20;&#x5165;&#x53C2;&#x6570;
    t.start()  #&#x6FC0;&#x6D3B;&#x7EBF;&#x7A0B;
</code></pre>
<ol start="11">
<li>
<p>快速排序和堆排序时间复杂度一样，为什么一般用快速排序<br>
“堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法”，时间复杂度是O(NlogN)，是基于关键字比较排序算法里比较理想的排序算法（另个是快速排序），空间复杂度O(1).<br>
堆分为最大堆和最小堆，最大堆的根节点最大，最小堆的根节点最小；最大堆用于递增堆排序，最小堆用于递减堆排序，下文提到的堆是指最大堆。<br>
堆排序的实现可以分为两个子算法：初始建堆和进行堆排序
快排：数组中交换数据，在数据量不是特别大，而且离散程度较高的情况下效率很高<br>
堆排序：创建堆，数据交换，调整堆的时间均很多<br>
所以在实际应用中，我们用快排会更多一点。</p>
</li>
<li>
<p>写一下单例设计模式<br>
核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。</p>
</li>
<li>
<p>如何检测sql语句的运行时间<br>
show variables like &quot;%pro%&quot;<br>
set profiling = 1;</p>
</li>
</ol>
<pre><code>set @d=now();
select * from comment;
select timestampdiff(second,@d,now());
</code></pre>
<ol start="7">
<li>
<p>什么是存储过程<br>
存储过程是数据库服务器端的一段程序，它有两种类型。一种类似于SELECT查询，用于检索数据，检索到的数据能够以数据集的形式返回给客户。另一种类似于INSERT或DELETE查询，它不返回数据，只是执行一个动作。有的服务器允许同一个存储过程既可以返回数据又可以执行动作。</p>
</li>
<li>
<p>说一说线程安全<br>
代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
</li>
<li>
<p>说一说gc
Python中的垃圾回收是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。
在Python中，如果一个对象的引用数为0，Python虚拟机就会回收这个对象的内存。</p>
</li>
<li>
<p>你觉得python跟java的区别
1.Python比Java简单，学习成本低，开发效率高<br>
2.Java运行效率高于Python，尤其是纯Python开发的程序，效率极低<br>
3.Java相关资料多，尤其是中文资料<br>
4.Java版本比较稳定，Python2和3不兼容导致大量类库失效<br>
5.Java开发偏向于软件工程，团队协同，Python更适合小型开发<br>
6.Java偏向于商业开发，Python适合于数据分析<br>
7.Java是一种静态类型语言，Python是一种动态类型语言<br>
8.Java中的所有变量需要先声明（类型）才能使用，Python中的变量不需要声明类型<br>
9.Java编译以后才能运行，Python直接就可以运行；<br>
10.JAVA 里的块用大括号对包括，Python 以冒号 + 四个空格缩进表示。<br>
11.JAVA 的类型要声明，Python 的类型不需要。<br>
12.JAVA 每行语句以分号结束，Python 可以不写分号。<br>
13.实现同一功能时，JAVA 要敲的键盘次数一般要比 Python 多。</p>
</li>
</ol>
</div><div class="m-content-container m-paging"><div class="m-paging-prev m-paging-item"><a href="index.html" class="href"><span class="ui-font-ydoc"></span>documents</a></div><div class="m-paging-next m-paging-item"><a href="intro.html" class="href">Introduction<span class="ui-font-ydoc"></span></a></div></div></div></div></div><div></div><script>
    var $content = document.getElementById('js-content');
    var $summaryItems = Array.prototype.slice.call(document.querySelectorAll('#js-menu .href'));
    var $menu = document.getElementById('js-menu');
    if ($menu && sessionStorage.menuScrollTop) {
		$menu.scrollTop = sessionStorage.menuScrollTop;
    }
    // 刷新页面但不切换 pathname 的时候，内容区恢复到记忆的高度
    if ($content && sessionStorage.contentScrollTop && window.location.pathname == sessionStorage.locationPathname) {
      $content.scrollTop = sessionStorage.contentScrollTop;
    }
    sessionStorage.setItem('locationPathname', window.location.pathname);</script><script src="../ydoc/scripts/plugins/dollar.min.js"></script><script src="../ydoc/scripts/plugins/responsive-nav.min.js"></script><script src="../ydoc/scripts/plugins/slideout.min.js"></script><script src="../ydoc/scripts/app.js"></script><script src="../ydoc/ydoc-plugin-search/core.js"></script><script src="../ydoc/ydoc-plugin-search/search.js"></script><script src="../search_json.js"></script></body></html>